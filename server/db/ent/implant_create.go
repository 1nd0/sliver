// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"

	"github.com/bishopfox/sliver/server/db/ent/implant"
	"github.com/facebookincubator/ent/dialect/sql/sqlgraph"
	"github.com/facebookincubator/ent/schema/field"
	"github.com/google/uuid"
)

// ImplantCreate is the builder for creating a Implant entity.
type ImplantCreate struct {
	config
	mutation *ImplantMutation
	hooks    []Hook
}

// SetID sets the ID field.
func (ic *ImplantCreate) SetID(u uuid.UUID) *ImplantCreate {
	ic.mutation.SetID(u)
	return ic
}

// SetGOOS sets the GOOS field.
func (ic *ImplantCreate) SetGOOS(s string) *ImplantCreate {
	ic.mutation.SetGOOS(s)
	return ic
}

// SetGOARCH sets the GOARCH field.
func (ic *ImplantCreate) SetGOARCH(s string) *ImplantCreate {
	ic.mutation.SetGOARCH(s)
	return ic
}

// SetECCClientCert sets the ECC_ClientCert field.
func (ic *ImplantCreate) SetECCClientCert(s string) *ImplantCreate {
	ic.mutation.SetECCClientCert(s)
	return ic
}

// SetECCClientKey sets the ECC_ClientKey field.
func (ic *ImplantCreate) SetECCClientKey(s string) *ImplantCreate {
	ic.mutation.SetECCClientKey(s)
	return ic
}

// SetRSACert sets the RSA_Cert field.
func (ic *ImplantCreate) SetRSACert(s string) *ImplantCreate {
	ic.mutation.SetRSACert(s)
	return ic
}

// SetDebug sets the Debug field.
func (ic *ImplantCreate) SetDebug(b bool) *ImplantCreate {
	ic.mutation.SetDebug(b)
	return ic
}

// SetObfuscateSymbols sets the ObfuscateSymbols field.
func (ic *ImplantCreate) SetObfuscateSymbols(b bool) *ImplantCreate {
	ic.mutation.SetObfuscateSymbols(b)
	return ic
}

// SetReconnectInterval sets the ReconnectInterval field.
func (ic *ImplantCreate) SetReconnectInterval(u uint32) *ImplantCreate {
	ic.mutation.SetReconnectInterval(u)
	return ic
}

// SetMaxConnectionErrors sets the MaxConnectionErrors field.
func (ic *ImplantCreate) SetMaxConnectionErrors(u uint32) *ImplantCreate {
	ic.mutation.SetMaxConnectionErrors(u)
	return ic
}

// SetLimitDomainJoined sets the LimitDomainJoined field.
func (ic *ImplantCreate) SetLimitDomainJoined(b bool) *ImplantCreate {
	ic.mutation.SetLimitDomainJoined(b)
	return ic
}

// SetLimitDatetime sets the LimitDatetime field.
func (ic *ImplantCreate) SetLimitDatetime(i int64) *ImplantCreate {
	ic.mutation.SetLimitDatetime(i)
	return ic
}

// SetLimitHostname sets the LimitHostname field.
func (ic *ImplantCreate) SetLimitHostname(s string) *ImplantCreate {
	ic.mutation.SetLimitHostname(s)
	return ic
}

// SetLimitUsername sets the LimitUsername field.
func (ic *ImplantCreate) SetLimitUsername(s string) *ImplantCreate {
	ic.mutation.SetLimitUsername(s)
	return ic
}

// SetOutputFormat sets the OutputFormat field.
func (ic *ImplantCreate) SetOutputFormat(i int) *ImplantCreate {
	ic.mutation.SetOutputFormat(i)
	return ic
}

// Mutation returns the ImplantMutation object of the builder.
func (ic *ImplantCreate) Mutation() *ImplantMutation {
	return ic.mutation
}

// Save creates the Implant in the database.
func (ic *ImplantCreate) Save(ctx context.Context) (*Implant, error) {
	if _, ok := ic.mutation.ID(); !ok {
		return nil, &ValidationError{Name: "ID", err: errors.New("ent: missing required field \"ID\"")}
	}
	if _, ok := ic.mutation.GOOS(); !ok {
		return nil, &ValidationError{Name: "GOOS", err: errors.New("ent: missing required field \"GOOS\"")}
	}
	if _, ok := ic.mutation.GOARCH(); !ok {
		return nil, &ValidationError{Name: "GOARCH", err: errors.New("ent: missing required field \"GOARCH\"")}
	}
	if _, ok := ic.mutation.ECCClientCert(); !ok {
		return nil, &ValidationError{Name: "ECC_ClientCert", err: errors.New("ent: missing required field \"ECC_ClientCert\"")}
	}
	if _, ok := ic.mutation.ECCClientKey(); !ok {
		return nil, &ValidationError{Name: "ECC_ClientKey", err: errors.New("ent: missing required field \"ECC_ClientKey\"")}
	}
	if _, ok := ic.mutation.RSACert(); !ok {
		return nil, &ValidationError{Name: "RSA_Cert", err: errors.New("ent: missing required field \"RSA_Cert\"")}
	}
	if _, ok := ic.mutation.Debug(); !ok {
		return nil, &ValidationError{Name: "Debug", err: errors.New("ent: missing required field \"Debug\"")}
	}
	if _, ok := ic.mutation.ObfuscateSymbols(); !ok {
		return nil, &ValidationError{Name: "ObfuscateSymbols", err: errors.New("ent: missing required field \"ObfuscateSymbols\"")}
	}
	if _, ok := ic.mutation.ReconnectInterval(); !ok {
		return nil, &ValidationError{Name: "ReconnectInterval", err: errors.New("ent: missing required field \"ReconnectInterval\"")}
	}
	if _, ok := ic.mutation.MaxConnectionErrors(); !ok {
		return nil, &ValidationError{Name: "MaxConnectionErrors", err: errors.New("ent: missing required field \"MaxConnectionErrors\"")}
	}
	if _, ok := ic.mutation.LimitDomainJoined(); !ok {
		return nil, &ValidationError{Name: "LimitDomainJoined", err: errors.New("ent: missing required field \"LimitDomainJoined\"")}
	}
	if _, ok := ic.mutation.LimitDatetime(); !ok {
		return nil, &ValidationError{Name: "LimitDatetime", err: errors.New("ent: missing required field \"LimitDatetime\"")}
	}
	if _, ok := ic.mutation.LimitHostname(); !ok {
		return nil, &ValidationError{Name: "LimitHostname", err: errors.New("ent: missing required field \"LimitHostname\"")}
	}
	if _, ok := ic.mutation.LimitUsername(); !ok {
		return nil, &ValidationError{Name: "LimitUsername", err: errors.New("ent: missing required field \"LimitUsername\"")}
	}
	if _, ok := ic.mutation.OutputFormat(); !ok {
		return nil, &ValidationError{Name: "OutputFormat", err: errors.New("ent: missing required field \"OutputFormat\"")}
	}
	var (
		err  error
		node *Implant
	)
	if len(ic.hooks) == 0 {
		node, err = ic.sqlSave(ctx)
	} else {
		var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
			mutation, ok := m.(*ImplantMutation)
			if !ok {
				return nil, fmt.Errorf("unexpected mutation type %T", m)
			}
			ic.mutation = mutation
			node, err = ic.sqlSave(ctx)
			mutation.done = true
			return node, err
		})
		for i := len(ic.hooks) - 1; i >= 0; i-- {
			mut = ic.hooks[i](mut)
		}
		if _, err := mut.Mutate(ctx, ic.mutation); err != nil {
			return nil, err
		}
	}
	return node, err
}

// SaveX calls Save and panics if Save returns an error.
func (ic *ImplantCreate) SaveX(ctx context.Context) *Implant {
	v, err := ic.Save(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

func (ic *ImplantCreate) sqlSave(ctx context.Context) (*Implant, error) {
	var (
		i     = &Implant{config: ic.config}
		_spec = &sqlgraph.CreateSpec{
			Table: implant.Table,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: implant.FieldID,
			},
		}
	)
	if value, ok := ic.mutation.ID(); ok {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeUUID,
			Value:  value,
			Column: implant.FieldID,
		})
		i.ID = value
	}
	if value, ok := ic.mutation.GOOS(); ok {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: implant.FieldGOOS,
		})
		i.GOOS = value
	}
	if value, ok := ic.mutation.GOARCH(); ok {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: implant.FieldGOARCH,
		})
		i.GOARCH = value
	}
	if value, ok := ic.mutation.ECCClientCert(); ok {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: implant.FieldECCClientCert,
		})
		i.ECCClientCert = value
	}
	if value, ok := ic.mutation.ECCClientKey(); ok {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: implant.FieldECCClientKey,
		})
		i.ECCClientKey = value
	}
	if value, ok := ic.mutation.RSACert(); ok {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: implant.FieldRSACert,
		})
		i.RSACert = value
	}
	if value, ok := ic.mutation.Debug(); ok {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeBool,
			Value:  value,
			Column: implant.FieldDebug,
		})
		i.Debug = value
	}
	if value, ok := ic.mutation.ObfuscateSymbols(); ok {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeBool,
			Value:  value,
			Column: implant.FieldObfuscateSymbols,
		})
		i.ObfuscateSymbols = value
	}
	if value, ok := ic.mutation.ReconnectInterval(); ok {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeUint32,
			Value:  value,
			Column: implant.FieldReconnectInterval,
		})
		i.ReconnectInterval = value
	}
	if value, ok := ic.mutation.MaxConnectionErrors(); ok {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeUint32,
			Value:  value,
			Column: implant.FieldMaxConnectionErrors,
		})
		i.MaxConnectionErrors = value
	}
	if value, ok := ic.mutation.LimitDomainJoined(); ok {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeBool,
			Value:  value,
			Column: implant.FieldLimitDomainJoined,
		})
		i.LimitDomainJoined = value
	}
	if value, ok := ic.mutation.LimitDatetime(); ok {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeInt64,
			Value:  value,
			Column: implant.FieldLimitDatetime,
		})
		i.LimitDatetime = value
	}
	if value, ok := ic.mutation.LimitHostname(); ok {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: implant.FieldLimitHostname,
		})
		i.LimitHostname = value
	}
	if value, ok := ic.mutation.LimitUsername(); ok {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: implant.FieldLimitUsername,
		})
		i.LimitUsername = value
	}
	if value, ok := ic.mutation.OutputFormat(); ok {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  value,
			Column: implant.FieldOutputFormat,
		})
		i.OutputFormat = value
	}
	if err := sqlgraph.CreateNode(ctx, ic.driver, _spec); err != nil {
		if cerr, ok := isSQLConstraintError(err); ok {
			err = cerr
		}
		return nil, err
	}
	id := _spec.ID.Value.(int64)
	i.ID = int(id)
	return i, nil
}
