// Code generated by entc, DO NOT EDIT.

package implant

import (
	"github.com/bishopfox/sliver/server/db/ent/predicate"
	"github.com/facebookincubator/ent/dialect/sql"
)

// ID filters vertices based on their identifier.
func ID(id int) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id int) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id int) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldID), id))
	})
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...int) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.In(s.C(FieldID), v...))
	})
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...int) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.NotIn(s.C(FieldID), v...))
	})
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id int) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldID), id))
	})
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id int) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldID), id))
	})
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id int) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldID), id))
	})
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id int) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldID), id))
	})
}

// GOOS applies equality check predicate on the "GOOS" field. It's identical to GOOSEQ.
func GOOS(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldGOOS), v))
	})
}

// GOARCH applies equality check predicate on the "GOARCH" field. It's identical to GOARCHEQ.
func GOARCH(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldGOARCH), v))
	})
}

// ECCClientCert applies equality check predicate on the "ECC_ClientCert" field. It's identical to ECCClientCertEQ.
func ECCClientCert(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldECCClientCert), v))
	})
}

// ECCClientKey applies equality check predicate on the "ECC_ClientKey" field. It's identical to ECCClientKeyEQ.
func ECCClientKey(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldECCClientKey), v))
	})
}

// RSACert applies equality check predicate on the "RSA_Cert" field. It's identical to RSACertEQ.
func RSACert(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRSACert), v))
	})
}

// Debug applies equality check predicate on the "Debug" field. It's identical to DebugEQ.
func Debug(v bool) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDebug), v))
	})
}

// ObfuscateSymbols applies equality check predicate on the "ObfuscateSymbols" field. It's identical to ObfuscateSymbolsEQ.
func ObfuscateSymbols(v bool) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldObfuscateSymbols), v))
	})
}

// ReconnectInterval applies equality check predicate on the "ReconnectInterval" field. It's identical to ReconnectIntervalEQ.
func ReconnectInterval(v uint32) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldReconnectInterval), v))
	})
}

// MaxConnectionErrors applies equality check predicate on the "MaxConnectionErrors" field. It's identical to MaxConnectionErrorsEQ.
func MaxConnectionErrors(v uint32) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMaxConnectionErrors), v))
	})
}

// LimitDomainJoined applies equality check predicate on the "LimitDomainJoined" field. It's identical to LimitDomainJoinedEQ.
func LimitDomainJoined(v bool) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLimitDomainJoined), v))
	})
}

// LimitDatetime applies equality check predicate on the "LimitDatetime" field. It's identical to LimitDatetimeEQ.
func LimitDatetime(v int64) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLimitDatetime), v))
	})
}

// LimitHostname applies equality check predicate on the "LimitHostname" field. It's identical to LimitHostnameEQ.
func LimitHostname(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLimitHostname), v))
	})
}

// LimitUsername applies equality check predicate on the "LimitUsername" field. It's identical to LimitUsernameEQ.
func LimitUsername(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLimitUsername), v))
	})
}

// OutputFormat applies equality check predicate on the "OutputFormat" field. It's identical to OutputFormatEQ.
func OutputFormat(v int) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldOutputFormat), v))
	})
}

// GOOSEQ applies the EQ predicate on the "GOOS" field.
func GOOSEQ(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldGOOS), v))
	})
}

// GOOSNEQ applies the NEQ predicate on the "GOOS" field.
func GOOSNEQ(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldGOOS), v))
	})
}

// GOOSIn applies the In predicate on the "GOOS" field.
func GOOSIn(vs ...string) predicate.Implant {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Implant(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldGOOS), v...))
	})
}

// GOOSNotIn applies the NotIn predicate on the "GOOS" field.
func GOOSNotIn(vs ...string) predicate.Implant {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Implant(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldGOOS), v...))
	})
}

// GOOSGT applies the GT predicate on the "GOOS" field.
func GOOSGT(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldGOOS), v))
	})
}

// GOOSGTE applies the GTE predicate on the "GOOS" field.
func GOOSGTE(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldGOOS), v))
	})
}

// GOOSLT applies the LT predicate on the "GOOS" field.
func GOOSLT(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldGOOS), v))
	})
}

// GOOSLTE applies the LTE predicate on the "GOOS" field.
func GOOSLTE(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldGOOS), v))
	})
}

// GOOSContains applies the Contains predicate on the "GOOS" field.
func GOOSContains(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldGOOS), v))
	})
}

// GOOSHasPrefix applies the HasPrefix predicate on the "GOOS" field.
func GOOSHasPrefix(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldGOOS), v))
	})
}

// GOOSHasSuffix applies the HasSuffix predicate on the "GOOS" field.
func GOOSHasSuffix(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldGOOS), v))
	})
}

// GOOSEqualFold applies the EqualFold predicate on the "GOOS" field.
func GOOSEqualFold(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldGOOS), v))
	})
}

// GOOSContainsFold applies the ContainsFold predicate on the "GOOS" field.
func GOOSContainsFold(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldGOOS), v))
	})
}

// GOARCHEQ applies the EQ predicate on the "GOARCH" field.
func GOARCHEQ(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldGOARCH), v))
	})
}

// GOARCHNEQ applies the NEQ predicate on the "GOARCH" field.
func GOARCHNEQ(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldGOARCH), v))
	})
}

// GOARCHIn applies the In predicate on the "GOARCH" field.
func GOARCHIn(vs ...string) predicate.Implant {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Implant(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldGOARCH), v...))
	})
}

// GOARCHNotIn applies the NotIn predicate on the "GOARCH" field.
func GOARCHNotIn(vs ...string) predicate.Implant {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Implant(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldGOARCH), v...))
	})
}

// GOARCHGT applies the GT predicate on the "GOARCH" field.
func GOARCHGT(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldGOARCH), v))
	})
}

// GOARCHGTE applies the GTE predicate on the "GOARCH" field.
func GOARCHGTE(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldGOARCH), v))
	})
}

// GOARCHLT applies the LT predicate on the "GOARCH" field.
func GOARCHLT(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldGOARCH), v))
	})
}

// GOARCHLTE applies the LTE predicate on the "GOARCH" field.
func GOARCHLTE(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldGOARCH), v))
	})
}

// GOARCHContains applies the Contains predicate on the "GOARCH" field.
func GOARCHContains(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldGOARCH), v))
	})
}

// GOARCHHasPrefix applies the HasPrefix predicate on the "GOARCH" field.
func GOARCHHasPrefix(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldGOARCH), v))
	})
}

// GOARCHHasSuffix applies the HasSuffix predicate on the "GOARCH" field.
func GOARCHHasSuffix(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldGOARCH), v))
	})
}

// GOARCHEqualFold applies the EqualFold predicate on the "GOARCH" field.
func GOARCHEqualFold(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldGOARCH), v))
	})
}

// GOARCHContainsFold applies the ContainsFold predicate on the "GOARCH" field.
func GOARCHContainsFold(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldGOARCH), v))
	})
}

// ECCClientCertEQ applies the EQ predicate on the "ECC_ClientCert" field.
func ECCClientCertEQ(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldECCClientCert), v))
	})
}

// ECCClientCertNEQ applies the NEQ predicate on the "ECC_ClientCert" field.
func ECCClientCertNEQ(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldECCClientCert), v))
	})
}

// ECCClientCertIn applies the In predicate on the "ECC_ClientCert" field.
func ECCClientCertIn(vs ...string) predicate.Implant {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Implant(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldECCClientCert), v...))
	})
}

// ECCClientCertNotIn applies the NotIn predicate on the "ECC_ClientCert" field.
func ECCClientCertNotIn(vs ...string) predicate.Implant {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Implant(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldECCClientCert), v...))
	})
}

// ECCClientCertGT applies the GT predicate on the "ECC_ClientCert" field.
func ECCClientCertGT(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldECCClientCert), v))
	})
}

// ECCClientCertGTE applies the GTE predicate on the "ECC_ClientCert" field.
func ECCClientCertGTE(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldECCClientCert), v))
	})
}

// ECCClientCertLT applies the LT predicate on the "ECC_ClientCert" field.
func ECCClientCertLT(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldECCClientCert), v))
	})
}

// ECCClientCertLTE applies the LTE predicate on the "ECC_ClientCert" field.
func ECCClientCertLTE(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldECCClientCert), v))
	})
}

// ECCClientCertContains applies the Contains predicate on the "ECC_ClientCert" field.
func ECCClientCertContains(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldECCClientCert), v))
	})
}

// ECCClientCertHasPrefix applies the HasPrefix predicate on the "ECC_ClientCert" field.
func ECCClientCertHasPrefix(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldECCClientCert), v))
	})
}

// ECCClientCertHasSuffix applies the HasSuffix predicate on the "ECC_ClientCert" field.
func ECCClientCertHasSuffix(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldECCClientCert), v))
	})
}

// ECCClientCertEqualFold applies the EqualFold predicate on the "ECC_ClientCert" field.
func ECCClientCertEqualFold(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldECCClientCert), v))
	})
}

// ECCClientCertContainsFold applies the ContainsFold predicate on the "ECC_ClientCert" field.
func ECCClientCertContainsFold(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldECCClientCert), v))
	})
}

// ECCClientKeyEQ applies the EQ predicate on the "ECC_ClientKey" field.
func ECCClientKeyEQ(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldECCClientKey), v))
	})
}

// ECCClientKeyNEQ applies the NEQ predicate on the "ECC_ClientKey" field.
func ECCClientKeyNEQ(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldECCClientKey), v))
	})
}

// ECCClientKeyIn applies the In predicate on the "ECC_ClientKey" field.
func ECCClientKeyIn(vs ...string) predicate.Implant {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Implant(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldECCClientKey), v...))
	})
}

// ECCClientKeyNotIn applies the NotIn predicate on the "ECC_ClientKey" field.
func ECCClientKeyNotIn(vs ...string) predicate.Implant {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Implant(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldECCClientKey), v...))
	})
}

// ECCClientKeyGT applies the GT predicate on the "ECC_ClientKey" field.
func ECCClientKeyGT(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldECCClientKey), v))
	})
}

// ECCClientKeyGTE applies the GTE predicate on the "ECC_ClientKey" field.
func ECCClientKeyGTE(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldECCClientKey), v))
	})
}

// ECCClientKeyLT applies the LT predicate on the "ECC_ClientKey" field.
func ECCClientKeyLT(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldECCClientKey), v))
	})
}

// ECCClientKeyLTE applies the LTE predicate on the "ECC_ClientKey" field.
func ECCClientKeyLTE(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldECCClientKey), v))
	})
}

// ECCClientKeyContains applies the Contains predicate on the "ECC_ClientKey" field.
func ECCClientKeyContains(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldECCClientKey), v))
	})
}

// ECCClientKeyHasPrefix applies the HasPrefix predicate on the "ECC_ClientKey" field.
func ECCClientKeyHasPrefix(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldECCClientKey), v))
	})
}

// ECCClientKeyHasSuffix applies the HasSuffix predicate on the "ECC_ClientKey" field.
func ECCClientKeyHasSuffix(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldECCClientKey), v))
	})
}

// ECCClientKeyEqualFold applies the EqualFold predicate on the "ECC_ClientKey" field.
func ECCClientKeyEqualFold(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldECCClientKey), v))
	})
}

// ECCClientKeyContainsFold applies the ContainsFold predicate on the "ECC_ClientKey" field.
func ECCClientKeyContainsFold(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldECCClientKey), v))
	})
}

// RSACertEQ applies the EQ predicate on the "RSA_Cert" field.
func RSACertEQ(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRSACert), v))
	})
}

// RSACertNEQ applies the NEQ predicate on the "RSA_Cert" field.
func RSACertNEQ(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldRSACert), v))
	})
}

// RSACertIn applies the In predicate on the "RSA_Cert" field.
func RSACertIn(vs ...string) predicate.Implant {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Implant(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldRSACert), v...))
	})
}

// RSACertNotIn applies the NotIn predicate on the "RSA_Cert" field.
func RSACertNotIn(vs ...string) predicate.Implant {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Implant(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldRSACert), v...))
	})
}

// RSACertGT applies the GT predicate on the "RSA_Cert" field.
func RSACertGT(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldRSACert), v))
	})
}

// RSACertGTE applies the GTE predicate on the "RSA_Cert" field.
func RSACertGTE(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldRSACert), v))
	})
}

// RSACertLT applies the LT predicate on the "RSA_Cert" field.
func RSACertLT(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldRSACert), v))
	})
}

// RSACertLTE applies the LTE predicate on the "RSA_Cert" field.
func RSACertLTE(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldRSACert), v))
	})
}

// RSACertContains applies the Contains predicate on the "RSA_Cert" field.
func RSACertContains(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldRSACert), v))
	})
}

// RSACertHasPrefix applies the HasPrefix predicate on the "RSA_Cert" field.
func RSACertHasPrefix(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldRSACert), v))
	})
}

// RSACertHasSuffix applies the HasSuffix predicate on the "RSA_Cert" field.
func RSACertHasSuffix(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldRSACert), v))
	})
}

// RSACertEqualFold applies the EqualFold predicate on the "RSA_Cert" field.
func RSACertEqualFold(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldRSACert), v))
	})
}

// RSACertContainsFold applies the ContainsFold predicate on the "RSA_Cert" field.
func RSACertContainsFold(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldRSACert), v))
	})
}

// DebugEQ applies the EQ predicate on the "Debug" field.
func DebugEQ(v bool) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDebug), v))
	})
}

// DebugNEQ applies the NEQ predicate on the "Debug" field.
func DebugNEQ(v bool) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldDebug), v))
	})
}

// ObfuscateSymbolsEQ applies the EQ predicate on the "ObfuscateSymbols" field.
func ObfuscateSymbolsEQ(v bool) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldObfuscateSymbols), v))
	})
}

// ObfuscateSymbolsNEQ applies the NEQ predicate on the "ObfuscateSymbols" field.
func ObfuscateSymbolsNEQ(v bool) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldObfuscateSymbols), v))
	})
}

// ReconnectIntervalEQ applies the EQ predicate on the "ReconnectInterval" field.
func ReconnectIntervalEQ(v uint32) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldReconnectInterval), v))
	})
}

// ReconnectIntervalNEQ applies the NEQ predicate on the "ReconnectInterval" field.
func ReconnectIntervalNEQ(v uint32) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldReconnectInterval), v))
	})
}

// ReconnectIntervalIn applies the In predicate on the "ReconnectInterval" field.
func ReconnectIntervalIn(vs ...uint32) predicate.Implant {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Implant(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldReconnectInterval), v...))
	})
}

// ReconnectIntervalNotIn applies the NotIn predicate on the "ReconnectInterval" field.
func ReconnectIntervalNotIn(vs ...uint32) predicate.Implant {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Implant(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldReconnectInterval), v...))
	})
}

// ReconnectIntervalGT applies the GT predicate on the "ReconnectInterval" field.
func ReconnectIntervalGT(v uint32) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldReconnectInterval), v))
	})
}

// ReconnectIntervalGTE applies the GTE predicate on the "ReconnectInterval" field.
func ReconnectIntervalGTE(v uint32) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldReconnectInterval), v))
	})
}

// ReconnectIntervalLT applies the LT predicate on the "ReconnectInterval" field.
func ReconnectIntervalLT(v uint32) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldReconnectInterval), v))
	})
}

// ReconnectIntervalLTE applies the LTE predicate on the "ReconnectInterval" field.
func ReconnectIntervalLTE(v uint32) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldReconnectInterval), v))
	})
}

// MaxConnectionErrorsEQ applies the EQ predicate on the "MaxConnectionErrors" field.
func MaxConnectionErrorsEQ(v uint32) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMaxConnectionErrors), v))
	})
}

// MaxConnectionErrorsNEQ applies the NEQ predicate on the "MaxConnectionErrors" field.
func MaxConnectionErrorsNEQ(v uint32) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldMaxConnectionErrors), v))
	})
}

// MaxConnectionErrorsIn applies the In predicate on the "MaxConnectionErrors" field.
func MaxConnectionErrorsIn(vs ...uint32) predicate.Implant {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Implant(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldMaxConnectionErrors), v...))
	})
}

// MaxConnectionErrorsNotIn applies the NotIn predicate on the "MaxConnectionErrors" field.
func MaxConnectionErrorsNotIn(vs ...uint32) predicate.Implant {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Implant(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldMaxConnectionErrors), v...))
	})
}

// MaxConnectionErrorsGT applies the GT predicate on the "MaxConnectionErrors" field.
func MaxConnectionErrorsGT(v uint32) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldMaxConnectionErrors), v))
	})
}

// MaxConnectionErrorsGTE applies the GTE predicate on the "MaxConnectionErrors" field.
func MaxConnectionErrorsGTE(v uint32) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldMaxConnectionErrors), v))
	})
}

// MaxConnectionErrorsLT applies the LT predicate on the "MaxConnectionErrors" field.
func MaxConnectionErrorsLT(v uint32) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldMaxConnectionErrors), v))
	})
}

// MaxConnectionErrorsLTE applies the LTE predicate on the "MaxConnectionErrors" field.
func MaxConnectionErrorsLTE(v uint32) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldMaxConnectionErrors), v))
	})
}

// LimitDomainJoinedEQ applies the EQ predicate on the "LimitDomainJoined" field.
func LimitDomainJoinedEQ(v bool) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLimitDomainJoined), v))
	})
}

// LimitDomainJoinedNEQ applies the NEQ predicate on the "LimitDomainJoined" field.
func LimitDomainJoinedNEQ(v bool) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldLimitDomainJoined), v))
	})
}

// LimitDatetimeEQ applies the EQ predicate on the "LimitDatetime" field.
func LimitDatetimeEQ(v int64) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLimitDatetime), v))
	})
}

// LimitDatetimeNEQ applies the NEQ predicate on the "LimitDatetime" field.
func LimitDatetimeNEQ(v int64) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldLimitDatetime), v))
	})
}

// LimitDatetimeIn applies the In predicate on the "LimitDatetime" field.
func LimitDatetimeIn(vs ...int64) predicate.Implant {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Implant(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldLimitDatetime), v...))
	})
}

// LimitDatetimeNotIn applies the NotIn predicate on the "LimitDatetime" field.
func LimitDatetimeNotIn(vs ...int64) predicate.Implant {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Implant(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldLimitDatetime), v...))
	})
}

// LimitDatetimeGT applies the GT predicate on the "LimitDatetime" field.
func LimitDatetimeGT(v int64) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldLimitDatetime), v))
	})
}

// LimitDatetimeGTE applies the GTE predicate on the "LimitDatetime" field.
func LimitDatetimeGTE(v int64) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldLimitDatetime), v))
	})
}

// LimitDatetimeLT applies the LT predicate on the "LimitDatetime" field.
func LimitDatetimeLT(v int64) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldLimitDatetime), v))
	})
}

// LimitDatetimeLTE applies the LTE predicate on the "LimitDatetime" field.
func LimitDatetimeLTE(v int64) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldLimitDatetime), v))
	})
}

// LimitHostnameEQ applies the EQ predicate on the "LimitHostname" field.
func LimitHostnameEQ(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLimitHostname), v))
	})
}

// LimitHostnameNEQ applies the NEQ predicate on the "LimitHostname" field.
func LimitHostnameNEQ(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldLimitHostname), v))
	})
}

// LimitHostnameIn applies the In predicate on the "LimitHostname" field.
func LimitHostnameIn(vs ...string) predicate.Implant {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Implant(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldLimitHostname), v...))
	})
}

// LimitHostnameNotIn applies the NotIn predicate on the "LimitHostname" field.
func LimitHostnameNotIn(vs ...string) predicate.Implant {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Implant(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldLimitHostname), v...))
	})
}

// LimitHostnameGT applies the GT predicate on the "LimitHostname" field.
func LimitHostnameGT(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldLimitHostname), v))
	})
}

// LimitHostnameGTE applies the GTE predicate on the "LimitHostname" field.
func LimitHostnameGTE(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldLimitHostname), v))
	})
}

// LimitHostnameLT applies the LT predicate on the "LimitHostname" field.
func LimitHostnameLT(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldLimitHostname), v))
	})
}

// LimitHostnameLTE applies the LTE predicate on the "LimitHostname" field.
func LimitHostnameLTE(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldLimitHostname), v))
	})
}

// LimitHostnameContains applies the Contains predicate on the "LimitHostname" field.
func LimitHostnameContains(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldLimitHostname), v))
	})
}

// LimitHostnameHasPrefix applies the HasPrefix predicate on the "LimitHostname" field.
func LimitHostnameHasPrefix(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldLimitHostname), v))
	})
}

// LimitHostnameHasSuffix applies the HasSuffix predicate on the "LimitHostname" field.
func LimitHostnameHasSuffix(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldLimitHostname), v))
	})
}

// LimitHostnameEqualFold applies the EqualFold predicate on the "LimitHostname" field.
func LimitHostnameEqualFold(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldLimitHostname), v))
	})
}

// LimitHostnameContainsFold applies the ContainsFold predicate on the "LimitHostname" field.
func LimitHostnameContainsFold(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldLimitHostname), v))
	})
}

// LimitUsernameEQ applies the EQ predicate on the "LimitUsername" field.
func LimitUsernameEQ(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLimitUsername), v))
	})
}

// LimitUsernameNEQ applies the NEQ predicate on the "LimitUsername" field.
func LimitUsernameNEQ(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldLimitUsername), v))
	})
}

// LimitUsernameIn applies the In predicate on the "LimitUsername" field.
func LimitUsernameIn(vs ...string) predicate.Implant {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Implant(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldLimitUsername), v...))
	})
}

// LimitUsernameNotIn applies the NotIn predicate on the "LimitUsername" field.
func LimitUsernameNotIn(vs ...string) predicate.Implant {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Implant(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldLimitUsername), v...))
	})
}

// LimitUsernameGT applies the GT predicate on the "LimitUsername" field.
func LimitUsernameGT(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldLimitUsername), v))
	})
}

// LimitUsernameGTE applies the GTE predicate on the "LimitUsername" field.
func LimitUsernameGTE(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldLimitUsername), v))
	})
}

// LimitUsernameLT applies the LT predicate on the "LimitUsername" field.
func LimitUsernameLT(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldLimitUsername), v))
	})
}

// LimitUsernameLTE applies the LTE predicate on the "LimitUsername" field.
func LimitUsernameLTE(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldLimitUsername), v))
	})
}

// LimitUsernameContains applies the Contains predicate on the "LimitUsername" field.
func LimitUsernameContains(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldLimitUsername), v))
	})
}

// LimitUsernameHasPrefix applies the HasPrefix predicate on the "LimitUsername" field.
func LimitUsernameHasPrefix(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldLimitUsername), v))
	})
}

// LimitUsernameHasSuffix applies the HasSuffix predicate on the "LimitUsername" field.
func LimitUsernameHasSuffix(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldLimitUsername), v))
	})
}

// LimitUsernameEqualFold applies the EqualFold predicate on the "LimitUsername" field.
func LimitUsernameEqualFold(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldLimitUsername), v))
	})
}

// LimitUsernameContainsFold applies the ContainsFold predicate on the "LimitUsername" field.
func LimitUsernameContainsFold(v string) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldLimitUsername), v))
	})
}

// OutputFormatEQ applies the EQ predicate on the "OutputFormat" field.
func OutputFormatEQ(v int) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldOutputFormat), v))
	})
}

// OutputFormatNEQ applies the NEQ predicate on the "OutputFormat" field.
func OutputFormatNEQ(v int) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldOutputFormat), v))
	})
}

// OutputFormatIn applies the In predicate on the "OutputFormat" field.
func OutputFormatIn(vs ...int) predicate.Implant {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Implant(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldOutputFormat), v...))
	})
}

// OutputFormatNotIn applies the NotIn predicate on the "OutputFormat" field.
func OutputFormatNotIn(vs ...int) predicate.Implant {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Implant(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldOutputFormat), v...))
	})
}

// OutputFormatGT applies the GT predicate on the "OutputFormat" field.
func OutputFormatGT(v int) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldOutputFormat), v))
	})
}

// OutputFormatGTE applies the GTE predicate on the "OutputFormat" field.
func OutputFormatGTE(v int) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldOutputFormat), v))
	})
}

// OutputFormatLT applies the LT predicate on the "OutputFormat" field.
func OutputFormatLT(v int) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldOutputFormat), v))
	})
}

// OutputFormatLTE applies the LTE predicate on the "OutputFormat" field.
func OutputFormatLTE(v int) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldOutputFormat), v))
	})
}

// And groups list of predicates with the AND operator between them.
func And(predicates ...predicate.Implant) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for _, p := range predicates {
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Or groups list of predicates with the OR operator between them.
func Or(predicates ...predicate.Implant) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for i, p := range predicates {
			if i > 0 {
				s1.Or()
			}
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Not applies the not operator on the given predicate.
func Not(p predicate.Implant) predicate.Implant {
	return predicate.Implant(func(s *sql.Selector) {
		p(s.Not())
	})
}
